做了一中午没想出来，看了题解也才知道原来网络流还能推结论。   

感觉是迄今为止做过最好的一道网络流了。    

和网上的题解不一样，有更多个人的理解。

[网上的题解](https://blog.csdn.net/ike940067893/article/details/88416014)建议先粗略看看这篇后再食用我的题解，因为网上的题解根本没写清楚。         

开头来的第一步其实还是挺好想的，嗯，感觉这道题限制很多，很难下手。   

还是寻找性质，我们先考虑扔掉一些限制来看这道题，如果我们不考虑 $B$ 的平衡值的话，我们的最优方法就是让所有 $max_{c} - min_c$ 的值最小，那么我们就尽量平均分配不就好了？    

现在又要考虑的是 $B$ 的所有情况，所以我们不妨先多来点假设，然后模仿递归嵌套一般依次证明最底层的假设成立。    

我们不妨考虑网络流，假设我们此时已经处理好了 $t$ 个公司应向每个城市连多少容量，我们跑 $t$ 次网络流，每次就把源点 $S$ 当成一个公司 $t$ ，$S$ 向每个 $A$ 城市连 $dgr_x / t$ 容量的边，原图的每条边也当成容量为 $1$ 的边，最后每个 $B$ 城市向汇点 $T$ 连容量为 Inf 的边。     

现在可知我们每次跑的网络流满流，就是不知道有没有方案可以使 $B$ 城市也都是被平均分配，网上的题解我也没怎么看懂，所以这里就讲一个我自己想的归纳法证明。    

假设此时原图没有边，那么我们一定可以使我们的 $A,B$ 城市都被均匀分配(因为没有边啊)，所以我们就考虑归纳证明，如果当前我们可以均匀分配 $A,B$ 城市，此时多了一条边，连接了节点 $u,v$ ，那么说明我们 $u$ 节点就需要被这 $t$ 个公司的其中一个在 $u$ 上只被分配了 $\lfloor \frac{dgr_u}{t}\rfloor$ 的公司给多分配一条航线，也就是 $\lfloor \frac{dgr_u}{t}\rfloor -> \lfloor\frac{dgr_u}{t}\rfloor  + 1$，此时我们的 $v$ 节点也是同理，由于我们总能找到这样的一个公司，所以多了一条边仍然可以均匀分配 $A,B$ ，证毕。    

所以说最后就看当前这个点的度数能否被 $t$ 除尽即可。 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 1e5 + 5;
int n,m,k,t,deg[Len][2],ans;
int main()
{
	scanf("%d %d %d %d",&n,&m,&k,&t);
	for(int i = 1 ; i <= k ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		deg[x][0] ++ , deg[y][1] ++;
	}
	for(int i = 1 ; i <= n ; i ++) if(deg[i][0] % t) ans ++;
	for(int i = 1 ; i <= m ; i ++) if(deg[i][1] % t) ans ++;
	printf("%d\n",ans);
	return 0;
}
```